
if (this.y >= canvas.height) {
this.py = canvas.height + (canvas.height - this.py) * bounce
this.y = canvas.height
} else if (this.y <= 0) {
this.py *= -1 * bounce
this.y = 0
}

return this
}

draw () {
let i = this.constraints.length
while (i--) this.constraints[i].draw()
}

resolve () {
if (this.pinX && this.pinY) {
this.x = this.pinX
this.y = this.pinY
return
}

this.constraints.forEach((constraint) => constraint.resolve())
}

attach (point) {
this.constraints.push(new Constraint(this, point))
}

free (constraint) {
this.constraints.splice(this.constraints.indexOf(constraint), 1)
}

addForce (x, y) {
this.vx += x
this.vy += y
}

pin (pinx, piny) {
this.pinX = pinx
this.pinY = piny
}
}

class Constraint {
constructor (p1, p2) {
this.p1 = p1
this.p2 = p2
this.length = spacing
}

resolve () {
let dx = this.p1.x - this.p2.x
let dy = this.p1.y - this.p2.y
let dist = Math.sqrt(dx * dx + dy * dy)

if (dist < this.length) return

let diff = (this.length - dist) / dist

if (dist > tearDist) this.p1.free(this)

let mul = diff * 0.5 * (1 - this.length / dist)

let px = dx * mul
let py = dy * mul

!this.p1.pinX && (this.p1.x += px)
!this.p1.pinY && (this.p1.y += py)
!this.p2.pinX && (this.p2.x -= px)
!this.p2.pinY && (this.p2.y -= py)

return this
}
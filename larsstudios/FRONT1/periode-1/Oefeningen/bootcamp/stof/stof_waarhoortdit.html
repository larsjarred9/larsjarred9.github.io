
draw () {
ctx.moveTo(this.p1.x, this.p1.y)
ctx.lineTo(this.p2.x, this.p2.y)
}
}

class Cloth {
constructor (free) {
this.points = []

let startX = canvas.width / 2 - clothX * spacing / 2

for (let y = 0; y <= clothY; y++) {
for (let x = 0; x <= clothX; x++) {
let point = new Point(startX + x * spacing, 20 + y * spacing)
!free && y === 0 && point.pin(point.x, point.y)
x !== 0 && point.attach(this.points[this.points.length - 1])
y !== 0 && point.attach(this.points[x + (y - 1) * (clothX + 1)])

this.points.push(point)
}
}
}

update (delta) {
let i = accuracy

while (i--) {
this.points.forEach((point) => {
point.resolve()
})
}

ctx.beginPath()
this.points.forEach((point) => {
point.update(delta * delta).draw()
})
ctx.stroke()
}
}

function setMouse (e) {
let rect = canvas.getBoundingClientRect()
mouse.px = mouse.x
mouse.py = mouse.y
mouse.x = e.clientX - rect.left
mouse.y = e.clientY - rect.top
}

canvas.onmousedown = (e) => {
mouse.button = e.which
mouse.down = true
setMouse(e)
}

canvas.onmousemove = setMouse

canvas.onmouseup = () => (mouse.down = false)

canvas.oncontextmenu = (e) => e.preventDefault()

let cloth = new Cloth()

function zeroG() {
gravity = 0
cloth = new Cloth(true)
}

;(function update (time) {
ctx.clearRect(0, 0, canvas.width, canvas.height)

cloth.update(0.016)

window.requestAnimFrame(update)
})(0)

</script>

</body>
</html>